<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flipper Zero Firmware: heatshrink</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Flipper Zero Firmware
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">heatshrink </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >A data compression/decompression library for embedded/real-time systems.</p>
<h1><a class="anchor" id="autotoc_md200"></a>
Key Features:</h1>
<ul>
<li><b>Low memory usage (as low as 50 bytes)</b> It is useful for some cases with less than 50 bytes, and useful for many general cases with &lt; 300 bytes.</li>
<li><b>Incremental, bounded CPU use</b> You can chew on input data in arbitrarily tiny bites. This is a useful property in hard real-time environments.</li>
<li><b>Can use either static or dynamic memory allocation</b> The library doesn't impose any constraints on memory management.</li>
<li><b>ISC license</b> You can use it freely, even for commercial purposes.</li>
</ul>
<h1><a class="anchor" id="autotoc_md201"></a>
Getting Started:</h1>
<p >There is a standalone command-line program, <code>heatshrink</code>, but the encoder and decoder can also be used as libraries, independent of each other. To do so, copy <code><a class="el" href="heatshrink__common_8h_source.html">heatshrink_common.h</a></code>, <code><a class="el" href="heatshrink__config_8h_source.html">heatshrink_config.h</a></code>, and either <code>heatshrink_encoder.c</code> or <code>heatshrink_decoder.c</code> (and their respective header) into your project. For projects that use both, static libraries are built that use static and dynamic allocation.</p>
<p >Dynamic allocation is used by default, but in an embedded context, you probably want to statically allocate the encoder/decoder. Set <code>HEATSHRINK_DYNAMIC_ALLOC</code> to 0 in <code><a class="el" href="heatshrink__config_8h_source.html">heatshrink_config.h</a></code>.</p>
<h2><a class="anchor" id="autotoc_md202"></a>
Basic Usage</h2>
<ol type="1">
<li>Allocate a <code><a class="el" href="structheatshrink__encoder.html">heatshrink_encoder</a></code> or <code><a class="el" href="structheatshrink__decoder.html">heatshrink_decoder</a></code> state machine using their <code>alloc</code> function, or statically allocate one and call their <code>reset</code> function to initialize them. (See below for configuration options.)</li>
<li>Use <code>sink</code> to sink an input buffer into the state machine. The <code>input_size</code> pointer argument will be set to indicate how many bytes of the input buffer were actually consumed. (If 0 bytes were conusmed, the buffer is full.)</li>
<li>Use <code>poll</code> to move output from the state machine into an output buffer. The <code>output_size</code> pointer argument will be set to indicate how many bytes were output, and the function return value will indicate whether further output is available. (The state machine may not output any data until it has received enough input.)</li>
</ol>
<p >Repeat steps 2 and 3 to stream data through the state machine. Since it's doing data compression, the input and output sizes can vary significantly. Looping will be necessary to buffer the input and output as the data is processed.</p>
<ol type="1">
<li>When the end of the input stream is reached, call <code>finish</code> to notify the state machine that no more input is available. The return value from <code>finish</code> will indicate whether any output remains. if so, call <code>poll</code> to get more.</li>
</ol>
<p >Continue calling <code>finish</code> and <code>poll</code>ing to flush remaining output until <code>finish</code> indicates that the output has been exhausted.</p>
<p >Sinking more data after <code>finish</code> has been called will not work without calling <code>reset</code> on the state machine.</p>
<h1><a class="anchor" id="autotoc_md203"></a>
Configuration</h1>
<p >heatshrink has a couple configuration options, which impact its resource usage and how effectively it can compress data. These are set when dynamically allocating an encoder or decoder, or in <code><a class="el" href="heatshrink__config_8h_source.html">heatshrink_config.h</a></code> if they are statically allocated.</p>
<ul>
<li><code>window_sz2</code>, <code>-w</code> in the CLI: Set the window size to 2^W bytes.</li>
</ul>
<p >The window size determines how far back in the input can be searched for repeated patterns. A <code>window_sz2</code> of 8 will only use 256 bytes (2^8), while a <code>window_sz2</code> of 10 will use 1024 bytes (2^10). The latter uses more memory, but may also compress more effectively by detecting more repetition.</p>
<p >The <code>window_sz2</code> setting currently must be between 4 and 15.</p>
<ul>
<li><code>lookahead_sz2</code>, <code>-l</code> in the CLI: Set the lookahead size to 2^L bytes.</li>
</ul>
<p >The lookahead size determines the max length for repeated patterns that are found. If the <code>lookahead_sz2</code> is 4, a 50-byte run of 'a' characters will be represented as several repeated 16-byte patterns (2^4 is 16), whereas a larger <code>lookahead_sz2</code> may be able to represent it all at once. The number of bits used for the lookahead size is fixed, so an overly large lookahead size can reduce compression by adding unused size bits to small patterns.</p>
<p >The <code>lookahead_sz2</code> setting currently must be between 3 and the <code>window_sz2</code> - 1.</p>
<ul>
<li><code>input_buffer_size</code> - How large an input buffer to use for the decoder. This impacts how much work the decoder can do in a single step, and a larger buffer will use more memory. An extremely small buffer (say, 1 byte) will add overhead due to lots of suspend/resume function calls, but should not change how well data compresses.</li>
</ul>
<h2><a class="anchor" id="autotoc_md204"></a>
Recommended Defaults</h2>
<p >For embedded/low memory contexts, a <code>window_sz2</code> in the 8 to 10 range is probably a good default, depending on how tight memory is. Smaller or larger window sizes may make better trade-offs in specific circumstances, but should be checked with representative data.</p>
<p >The <code>lookahead_sz2</code> should probably start near the <code>window_sz2</code>/2, e.g. -w 8 -l 4 or -w 10 -l 5. The command-line program can be used to measure how well test data works with different settings.</p>
<h1><a class="anchor" id="autotoc_md205"></a>
More Information and Benchmarks:</h1>
<p >heatshrink is based on <a href="http://en.wikipedia.org/wiki/Lempel-Ziv-Storer-Szymanski">LZSS</a>, since it's particularly suitable for compression in small amounts of memory. It can use an optional, small <a href="http://spin.atomicobject.com/2014/01/13/lightweight-indexing-for-embedded-systems/">index</a> to make compression significantly faster, but otherwise can run in under 100 bytes of memory. The index currently adds 2^(window size+1) bytes to memory usage for compression, and temporarily allocates 512 bytes on the stack during index construction (if the index is enabled).</p>
<p >For more information, see the <a href="http://spin.atomicobject.com/2013/03/14/heatshrink-embedded-data-compression/">blog post</a> for an overview, and the <code><a class="el" href="heatshrink__encoder_8h_source.html">heatshrink_encoder.h</a></code> / <code><a class="el" href="heatshrink__decoder_8h_source.html">heatshrink_decoder.h</a></code> header files for API documentation.</p>
<h1><a class="anchor" id="autotoc_md206"></a>
Build Status</h1>
<p ><a href="http://travis-ci.org/atomicobject/heatshrink"><img src="https://travis-ci.org/atomicobject/heatshrink.png" alt="Build Status" class="inline"/></a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
